import { i as is_function, w as writable, S as SvelteComponentDev, a as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, v as validate_slots, e as element, b as claim_element, f as children, g as detach_dev, h as attr_dev, j as add_location, k as insert_hydration_dev, u as update_slot_base, l as get_all_dirty_from_scope, m as get_slot_changes, t as transition_in, n as add_render_callback, o as create_bidirectional_transition, p as transition_out, q as createEventDispatcher, r as create_component, x as claim_component, y as mount_component, z as destroy_component, A as space, B as text, C as claim_space, D as claim_text, E as append_hydration_dev, F as listen_dev, G as set_data_dev, H as globals, I as bubble, J as src_url_equal, K as group_outros, L as check_outros, M as noop, N as toggle_class, O as run_all, P as prop_dev, Q as set_input_value, R as binding_callbacks, T as bind, U as prevent_default, V as add_flush_callback, W as onMount, X as onDestroy, Y as empty, Z as query_selector_all, _ as validate_each_argument, $ as validate_each_keys, a0 as fix_position, a1 as create_animation, a2 as create_in_transition, a3 as update_keyed_each, a4 as fix_and_outro_and_destroy_block } from './client.6837ece9.js';
import { c as cubicOut, s as slide, B as Button, f as fade, a as fly, b as scale } from './Button.b005cc67.js';

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

const meetups = writable([]);

const customMeetupStore = {
  subscribe: meetups.subscribe,
  setMeetups: (meetupArray) => {
    meetups.set(meetupArray);
  },
  addMeetup: (meetupData) => {
    const newMeetup = {
      ...meetupData,
    };

    meetups.update((items) => {
      return [newMeetup, ...items];
    });
  },
  updateMeetup: (id, meetupData) => {
    meetups.update((items) => {
      const meetupIndex = items.findIndex((i) => i.id === id);
      const updatedMeetup = { ...items[meetupIndex], ...meetupData };
      const updatedMeetups = [...items];
      updatedMeetups[meetupIndex] = updatedMeetup;

      return updatedMeetups;
    });
  },
  deleteMeetup: (id) => {
    meetups.update((items) => {
      return items.filter((i) => i.id !== id);
    });
  },
  toggleFavorite: (id) => {
    meetups.update((items) => {
      const updatedMeetup = { ...items.find((m) => m.id === id) };
      updatedMeetup.isFavorite = !updatedMeetup.isFavorite;

      const meetupIndex = items.findIndex((m) => m.id === id);
      const updatedMeetups = [...items];

      updatedMeetups[meetupIndex] = updatedMeetup;
      return updatedMeetups;
    });
  },
};

/* src\components\UI\Badge.svelte generated by Svelte v3.44.3 */
const file$8 = "src\\components\\UI\\Badge.svelte";

function create_fragment$8(ctx) {
	let span;
	let span_transition;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1m0spz6");
			add_location(span, file$8, 4, 0, 69);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!span_transition) span_transition = create_bidirectional_transition(span, slide, {}, true);
				span_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (!span_transition) span_transition = create_bidirectional_transition(span, slide, {}, false);
			span_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			if (detaching && span_transition) span_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Badge', slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ slide });
	return [$$scope, slots];
}

class Badge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badge",
			options,
			id: create_fragment$8.name
		});
	}
}

/* src\components\UI\Modal.svelte generated by Svelte v3.44.3 */
const file$7 = "src\\components\\UI\\Modal.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});

// (23:6) <Button on:click={cancelModal}>
function create_default_slot$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Close");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(23:6) <Button on:click={cancelModal}>",
		ctx
	});

	return block;
}

// (22:24)         
function fallback_block(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*cancelModal*/ ctx[1]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(22:24)         ",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div0;
	let div0_transition;
	let t0;
	let div2;
	let h1;
	let t1;
	let t2;
	let div1;
	let t3;
	let footer;
	let div2_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const footer_slot_template = /*#slots*/ ctx[2].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context);
	const footer_slot_or_fallback = footer_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div2 = element("div");
			h1 = element("h1");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			t3 = space();
			footer = element("footer");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h1 = claim_element(div2_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			footer = claim_element(div2_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			if (footer_slot_or_fallback) footer_slot_or_fallback.l(footer_nodes);
			footer_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-backdrop svelte-rj5ywu");
			add_location(div0, file$7, 14, 0, 293);
			attr_dev(h1, "class", "svelte-rj5ywu");
			add_location(h1, file$7, 16, 2, 415);
			attr_dev(div1, "class", "content svelte-rj5ywu");
			add_location(div1, file$7, 17, 2, 435);
			attr_dev(footer, "class", "svelte-rj5ywu");
			add_location(footer, file$7, 20, 2, 484);
			attr_dev(div2, "class", "modal svelte-rj5ywu");
			add_location(div2, file$7, 15, 0, 364);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div0, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, div2, anchor);
			append_hydration_dev(div2, h1);
			append_hydration_dev(h1, t1);
			append_hydration_dev(div2, t2);
			append_hydration_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration_dev(div2, t3);
			append_hydration_dev(div2, footer);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(footer, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div0, "click", /*cancelModal*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[3], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, true);
				div0_transition.run(1);
			});

			transition_in(default_slot, local);
			transition_in(footer_slot_or_fallback, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, { y: 300 }, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, false);
			div0_transition.run(0);
			transition_out(default_slot, local);
			transition_out(footer_slot_or_fallback, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, { y: 300 }, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching && div0_transition) div0_transition.end();
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Modal', slots, ['default','footer']);
	let { title } = $$props;
	let dispatch = createEventDispatcher();

	function cancelModal() {
		dispatch('cancel');
	}

	const writable_props = ['title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Button,
		createEventDispatcher,
		fade,
		fly,
		title,
		dispatch,
		cancelModal
	});

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('dispatch' in $$props) dispatch = $$props.dispatch;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, cancelModal, slots, $$scope];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { title: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
			console.warn("<Modal> was created without expected prop 'title'");
		}
	}

	get title() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\UI\Error.svelte generated by Svelte v3.44.3 */

const { Error: Error_1$3 } = globals;
const file$6 = "src\\components\\UI\\Error.svelte";

// (7:0) <Modal title="An error occured!" on:cancel>
function create_default_slot$3(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*message*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*message*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$6, 7, 2, 134);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*message*/ 1) set_data_dev(t, /*message*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(7:0) <Modal title=\\\"An error occured!\\\" on:cancel>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				title: "An error occured!",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	modal.$on("cancel", /*cancel_handler*/ ctx[1]);

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(modal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, message*/ 5) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Error', slots, []);
	let { message } = $$props;
	const writable_props = ['message'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	function cancel_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('message' in $$props) $$invalidate(0, message = $$props.message);
	};

	$$self.$capture_state = () => ({ Modal, message });

	$$self.$inject_state = $$props => {
		if ('message' in $$props) $$invalidate(0, message = $$props.message);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [message, cancel_handler];
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { message: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*message*/ ctx[0] === undefined && !('message' in props)) {
			console.warn("<Error> was created without expected prop 'message'");
		}
	}

	get message() {
		throw new Error_1$3("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error_1$3("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Meetup\MeetupItem.svelte generated by Svelte v3.44.3 */

const { Error: Error_1$2, console: console_1$2 } = globals;
const file$5 = "src\\components\\Meetup\\MeetupItem.svelte";

// (54:0) {#if error}
function create_if_block_2$1(ctx) {
	let error_1;
	let current;

	error_1 = new Error$1({
			props: { message: /*error*/ ctx[7].message },
			$$inline: true
		});

	error_1.$on("cancel", /*clearError*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(error_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(error_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const error_1_changes = {};
			if (dirty & /*error*/ 128) error_1_changes.message = /*error*/ ctx[7].message;
			error_1.$set(error_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(error_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(54:0) {#if error}",
		ctx
	});

	return block;
}

// (62:6) {#if isFav}
function create_if_block_1$3(ctx) {
	let badge;
	let current;

	badge = new Badge({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(badge.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(badge, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(62:6) {#if isFav}",
		ctx
	});

	return block;
}

// (62:18) <Badge>
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("FAVORITE");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "FAVORITE");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(62:18) <Badge>",
		ctx
	});

	return block;
}

// (74:4) <Button type="button" mode="outline" on:click={() => dispatch('edit', id)}        >
function create_default_slot_2$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Edit");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(74:4) <Button type=\\\"button\\\" mode=\\\"outline\\\" on:click={() => dispatch('edit', id)}        >",
		ctx
	});

	return block;
}

// (79:4) {:else}
function create_else_block$2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				mode: "outline",
				type: "button",
				color: /*isFav*/ ctx[6] ? undefined : 'success',
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*toggleFavorite*/ ctx[10]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*isFav*/ 64) button_changes.color = /*isFav*/ ctx[6] ? undefined : 'success';

			if (dirty & /*$$scope, isFav*/ 8256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(79:4) {:else}",
		ctx
	});

	return block;
}

// (77:4) {#if isLoading}
function create_if_block$3(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Changing...");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Changing...");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$5, 77, 6, 1704);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(77:4) {#if isLoading}",
		ctx
	});

	return block;
}

// (80:6) <Button          mode="outline"          type="button"          color={isFav ? undefined : 'success'}          on:click={toggleFavorite}>
function create_default_slot_1$1(ctx) {
	let t_value = (/*isFav*/ ctx[6] ? 'Unfavorite' : 'Favorite') + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*isFav*/ 64 && t_value !== (t_value = (/*isFav*/ ctx[6] ? 'Unfavorite' : 'Favorite') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(80:6) <Button          mode=\\\"outline\\\"          type=\\\"button\\\"          color={isFav ? undefined : 'success'}          on:click={toggleFavorite}>",
		ctx
	});

	return block;
}

// (87:4) <Button type="button" href="/{id}">
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Show Details");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Show Details");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(87:4) <Button type=\\\"button\\\" href=\\\"/{id}\\\">",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let t0;
	let article;
	let header;
	let h1;
	let t1;
	let t2;
	let t3;
	let h2;
	let t4;
	let t5;
	let p0;
	let t6;
	let t7;
	let div0;
	let img;
	let img_src_value;
	let t8;
	let div1;
	let p1;
	let t9;
	let t10;
	let footer;
	let button0;
	let t11;
	let current_block_type_index;
	let if_block2;
	let t12;
	let button1;
	let current;
	let if_block0 = /*error*/ ctx[7] && create_if_block_2$1(ctx);
	let if_block1 = /*isFav*/ ctx[6] && create_if_block_1$3(ctx);

	button0 = new Button({
			props: {
				type: "button",
				mode: "outline",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[12]);
	const if_block_creators = [create_if_block$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button1 = new Button({
			props: {
				type: "button",
				href: "/" + /*id*/ ctx[0],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			article = element("article");
			header = element("header");
			h1 = element("h1");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			h2 = element("h2");
			t4 = text(/*subtitle*/ ctx[2]);
			t5 = space();
			p0 = element("p");
			t6 = text(/*address*/ ctx[5]);
			t7 = space();
			div0 = element("div");
			img = element("img");
			t8 = space();
			div1 = element("div");
			p1 = element("p");
			t9 = text(/*description*/ ctx[3]);
			t10 = space();
			footer = element("footer");
			create_component(button0.$$.fragment);
			t11 = space();
			if_block2.c();
			t12 = space();
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			header = claim_element(article_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h1 = claim_element(header_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, /*title*/ ctx[1]);
			t2 = claim_space(h1_nodes);
			if (if_block1) if_block1.l(h1_nodes);
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(header_nodes);
			h2 = claim_element(header_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t4 = claim_text(h2_nodes, /*subtitle*/ ctx[2]);
			h2_nodes.forEach(detach_dev);
			t5 = claim_space(header_nodes);
			p0 = claim_element(header_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t6 = claim_text(p0_nodes, /*address*/ ctx[5]);
			p0_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t7 = claim_space(article_nodes);
			div0 = claim_element(article_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach_dev);
			t8 = claim_space(article_nodes);
			div1 = claim_element(article_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p1 = claim_element(div1_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			t9 = claim_text(p1_nodes, /*description*/ ctx[3]);
			p1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t10 = claim_space(article_nodes);
			footer = claim_element(article_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			claim_component(button0.$$.fragment, footer_nodes);
			t11 = claim_space(footer_nodes);
			if_block2.l(footer_nodes);
			t12 = claim_space(footer_nodes);
			claim_component(button1.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-lym3nh");
			add_location(h1, file$5, 59, 4, 1287);
			attr_dev(h2, "class", "svelte-lym3nh");
			add_location(h2, file$5, 63, 4, 1372);
			attr_dev(p0, "class", "svelte-lym3nh");
			add_location(p0, file$5, 64, 4, 1397);
			attr_dev(header, "class", "svelte-lym3nh");
			add_location(header, file$5, 58, 2, 1273);
			if (!src_url_equal(img.src, img_src_value = /*imageURL*/ ctx[4])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "svelte-lym3nh");
			add_location(img, file$5, 67, 4, 1455);
			attr_dev(div0, "class", "image svelte-lym3nh");
			add_location(div0, file$5, 66, 2, 1430);
			attr_dev(p1, "class", "svelte-lym3nh");
			add_location(p1, file$5, 70, 4, 1525);
			attr_dev(div1, "class", "content svelte-lym3nh");
			add_location(div1, file$5, 69, 2, 1498);
			attr_dev(footer, "class", "svelte-lym3nh");
			add_location(footer, file$5, 72, 2, 1559);
			attr_dev(article, "class", "svelte-lym3nh");
			add_location(article, file$5, 57, 0, 1260);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, article, anchor);
			append_hydration_dev(article, header);
			append_hydration_dev(header, h1);
			append_hydration_dev(h1, t1);
			append_hydration_dev(h1, t2);
			if (if_block1) if_block1.m(h1, null);
			append_hydration_dev(header, t3);
			append_hydration_dev(header, h2);
			append_hydration_dev(h2, t4);
			append_hydration_dev(header, t5);
			append_hydration_dev(header, p0);
			append_hydration_dev(p0, t6);
			append_hydration_dev(article, t7);
			append_hydration_dev(article, div0);
			append_hydration_dev(div0, img);
			append_hydration_dev(article, t8);
			append_hydration_dev(article, div1);
			append_hydration_dev(div1, p1);
			append_hydration_dev(p1, t9);
			append_hydration_dev(article, t10);
			append_hydration_dev(article, footer);
			mount_component(button0, footer, null);
			append_hydration_dev(footer, t11);
			if_blocks[current_block_type_index].m(footer, null);
			append_hydration_dev(footer, t12);
			mount_component(button1, footer, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*error*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*error*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);

			if (/*isFav*/ ctx[6]) {
				if (if_block1) {
					if (dirty & /*isFav*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(h1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*subtitle*/ 4) set_data_dev(t4, /*subtitle*/ ctx[2]);
			if (!current || dirty & /*address*/ 32) set_data_dev(t6, /*address*/ ctx[5]);

			if (!current || dirty & /*imageURL*/ 16 && !src_url_equal(img.src, img_src_value = /*imageURL*/ ctx[4])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*description*/ 8) set_data_dev(t9, /*description*/ ctx[3]);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(footer, t12);
			}

			const button1_changes = {};
			if (dirty & /*id*/ 1) button1_changes.href = "/" + /*id*/ ctx[0];

			if (dirty & /*$$scope*/ 8192) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(button0.$$.fragment, local);
			transition_in(if_block2);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(button0.$$.fragment, local);
			transition_out(if_block2);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(article);
			if (if_block1) if_block1.d();
			destroy_component(button0);
			if_blocks[current_block_type_index].d();
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MeetupItem', slots, []);
	let { id } = $$props;
	let { title } = $$props;
	let { subtitle } = $$props;
	let { description } = $$props;
	let { imageURL } = $$props;
	let { address } = $$props;
	let { isFav } = $$props;
	let error;
	let isLoading = false;
	let dispatch = createEventDispatcher();

	function toggleFavorite() {
		$$invalidate(8, isLoading = true);

		fetch(`https://meetups-e2e4b-default-rtdb.firebaseio.com/meetups/${id}.json`, {
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ isFavorite: !isFav })
		}).then(res => {
			if (!res.ok) {
				throw new Error$1('Failed!');
			}

			customMeetupStore.toggleFavorite(id);
			$$invalidate(8, isLoading = false);
		}).catch(err => {
			$$invalidate(7, error = err);
			$$invalidate(8, isLoading = false);
			console.log(err);
		});
	}

	function clearError() {
		$$invalidate(7, error = null);
	}

	const writable_props = ['id', 'title', 'subtitle', 'description', 'imageURL', 'address', 'isFav'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<MeetupItem> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch('edit', id);

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
		if ('description' in $$props) $$invalidate(3, description = $$props.description);
		if ('imageURL' in $$props) $$invalidate(4, imageURL = $$props.imageURL);
		if ('address' in $$props) $$invalidate(5, address = $$props.address);
		if ('isFav' in $$props) $$invalidate(6, isFav = $$props.isFav);
	};

	$$self.$capture_state = () => ({
		meetups: customMeetupStore,
		Button,
		Badge,
		Error: Error$1,
		createEventDispatcher,
		id,
		title,
		subtitle,
		description,
		imageURL,
		address,
		isFav,
		error,
		isLoading,
		dispatch,
		toggleFavorite,
		clearError
	});

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
		if ('description' in $$props) $$invalidate(3, description = $$props.description);
		if ('imageURL' in $$props) $$invalidate(4, imageURL = $$props.imageURL);
		if ('address' in $$props) $$invalidate(5, address = $$props.address);
		if ('isFav' in $$props) $$invalidate(6, isFav = $$props.isFav);
		if ('error' in $$props) $$invalidate(7, error = $$props.error);
		if ('isLoading' in $$props) $$invalidate(8, isLoading = $$props.isLoading);
		if ('dispatch' in $$props) $$invalidate(9, dispatch = $$props.dispatch);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		id,
		title,
		subtitle,
		description,
		imageURL,
		address,
		isFav,
		error,
		isLoading,
		dispatch,
		toggleFavorite,
		clearError,
		click_handler
	];
}

class MeetupItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			id: 0,
			title: 1,
			subtitle: 2,
			description: 3,
			imageURL: 4,
			address: 5,
			isFav: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MeetupItem",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !('id' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'id'");
		}

		if (/*title*/ ctx[1] === undefined && !('title' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'title'");
		}

		if (/*subtitle*/ ctx[2] === undefined && !('subtitle' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'subtitle'");
		}

		if (/*description*/ ctx[3] === undefined && !('description' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'description'");
		}

		if (/*imageURL*/ ctx[4] === undefined && !('imageURL' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'imageURL'");
		}

		if (/*address*/ ctx[5] === undefined && !('address' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'address'");
		}

		if (/*isFav*/ ctx[6] === undefined && !('isFav' in props)) {
			console_1$2.warn("<MeetupItem> was created without expected prop 'isFav'");
		}
	}

	get id() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get description() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set description(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imageURL() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imageURL(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get address() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set address(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isFav() {
		throw new Error_1$2("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isFav(value) {
		throw new Error_1$2("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Meetup\MeetupFilter.svelte generated by Svelte v3.44.3 */
const file$4 = "src\\components\\Meetup\\MeetupFilter.svelte";

function create_fragment$4(ctx) {
	let div;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			t0 = text("All");
			t1 = space();
			button1 = element("button");
			t2 = text("Favorite");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "All");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "Favorite");
			button1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "svelte-wewm0q");
			toggle_class(button0, "active", /*clickedButton*/ ctx[0] === 0);
			add_location(button0, file$4, 8, 2, 154);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "svelte-wewm0q");
			toggle_class(button1, "active", /*clickedButton*/ ctx[0] === 1);
			add_location(button1, file$4, 16, 2, 328);
			attr_dev(div, "class", "svelte-wewm0q");
			add_location(div, file$4, 7, 0, 145);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, button0);
			append_hydration_dev(button0, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, button1);
			append_hydration_dev(button1, t2);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*clickedButton*/ 1) {
				toggle_class(button0, "active", /*clickedButton*/ ctx[0] === 0);
			}

			if (dirty & /*clickedButton*/ 1) {
				toggle_class(button1, "active", /*clickedButton*/ ctx[0] === 1);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MeetupFilter', slots, []);
	let clickedButton = 0;
	let dispatch = createEventDispatcher();
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeetupFilter> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, clickedButton = 0);
		dispatch('select', 0);
	};

	const click_handler_1 = () => {
		$$invalidate(0, clickedButton = 1);
		dispatch('select', 1);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		clickedButton,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('clickedButton' in $$props) $$invalidate(0, clickedButton = $$props.clickedButton);
		if ('dispatch' in $$props) $$invalidate(1, dispatch = $$props.dispatch);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clickedButton, dispatch, click_handler, click_handler_1];
}

class MeetupFilter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MeetupFilter",
			options,
			id: create_fragment$4.name
		});
	}
}

function isEmpty(val) {
  return val.trim().length === 0;
}

function isValidEmail(val) {
  return new RegExp(
    "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"
  ).test(val);
}

/* src\components\UI\TextInput.svelte generated by Svelte v3.44.3 */

const file$3 = "src\\components\\UI\\TextInput.svelte";

// (24:2) {:else}
function create_else_block$1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, id: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", /*type*/ ctx[4]);
			attr_dev(input, "id", /*id*/ ctx[2]);
			input.value = /*value*/ ctx[0];
			attr_dev(input, "class", "svelte-1ojktrx");
			toggle_class(input, "invalid", !/*valid*/ ctx[6] && /*touched*/ ctx[8]);
			add_location(input, file$3, 24, 4, 522);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_handler*/ ctx[9], false, false, false),
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*type*/ 16) {
				attr_dev(input, "type", /*type*/ ctx[4]);
			}

			if (dirty & /*id*/ 4) {
				attr_dev(input, "id", /*id*/ ctx[2]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				prop_dev(input, "value", /*value*/ ctx[0]);
			}

			if (dirty & /*valid, touched*/ 320) {
				toggle_class(input, "invalid", !/*valid*/ ctx[6] && /*touched*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(24:2) {:else}",
		ctx
	});

	return block;
}

// (16:2) {#if controlType === "textarea"}
function create_if_block_1$2(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", { rows: true, id: true, class: true });
			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(textarea, "rows", /*rows*/ ctx[5]);
			attr_dev(textarea, "id", /*id*/ ctx[2]);
			attr_dev(textarea, "class", "svelte-1ojktrx");
			toggle_class(textarea, "invalid", !/*valid*/ ctx[6] && /*touched*/ ctx[8]);
			add_location(textarea, file$3, 16, 4, 363);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[10]),
					listen_dev(textarea, "blur", /*blur_handler*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*rows*/ 32) {
				attr_dev(textarea, "rows", /*rows*/ ctx[5]);
			}

			if (dirty & /*id*/ 4) {
				attr_dev(textarea, "id", /*id*/ ctx[2]);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			if (dirty & /*valid, touched*/ 320) {
				toggle_class(textarea, "invalid", !/*valid*/ ctx[6] && /*touched*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(16:2) {#if controlType === \\\"textarea\\\"}",
		ctx
	});

	return block;
}

// (34:2) {#if validityMessage && !valid && touched}
function create_if_block$2(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*validityMessage*/ ctx[7]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*validityMessage*/ ctx[7]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "error-message svelte-1ojktrx");
			add_location(div, file$3, 34, 4, 735);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*validityMessage*/ 128) set_data_dev(t, /*validityMessage*/ ctx[7]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(34:2) {#if validityMessage && !valid && touched}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let t2;

	function select_block_type(ctx, dirty) {
		if (/*controlType*/ ctx[1] === "textarea") return create_if_block_1$2;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*validityMessage*/ ctx[7] && !/*valid*/ ctx[6] && /*touched*/ ctx[8] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[3]);
			t1 = space();
			if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*label*/ ctx[3]);
			label_1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*id*/ ctx[2]);
			attr_dev(label_1, "class", "svelte-1ojktrx");
			add_location(label_1, file$3, 14, 2, 290);
			attr_dev(div, "class", "form-control svelte-1ojktrx");
			add_location(div, file$3, 13, 0, 260);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, label_1);
			append_hydration_dev(label_1, t0);
			append_hydration_dev(div, t1);
			if_block0.m(div, null);
			append_hydration_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 8) set_data_dev(t0, /*label*/ ctx[3]);

			if (dirty & /*id*/ 4) {
				attr_dev(label_1, "for", /*id*/ ctx[2]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t2);
				}
			}

			if (/*validityMessage*/ ctx[7] && !/*valid*/ ctx[6] && /*touched*/ ctx[8]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TextInput', slots, []);
	let { controlType = undefined } = $$props;
	let { id } = $$props;
	let { label } = $$props;
	let { type = "text" } = $$props;
	let { value } = $$props;
	let { rows = 3 } = $$props;
	let { valid = true } = $$props;
	let { validityMessage } = $$props;
	let touched = false;

	const writable_props = [
		'controlType',
		'id',
		'label',
		'type',
		'value',
		'rows',
		'valid',
		'validityMessage'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInput> was created with unknown prop '${key}'`);
	});

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler = () => $$invalidate(8, touched = true);
	const blur_handler_1 = () => $$invalidate(8, touched = true);

	$$self.$$set = $$props => {
		if ('controlType' in $$props) $$invalidate(1, controlType = $$props.controlType);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
		if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
		if ('validityMessage' in $$props) $$invalidate(7, validityMessage = $$props.validityMessage);
	};

	$$self.$capture_state = () => ({
		controlType,
		id,
		label,
		type,
		value,
		rows,
		valid,
		validityMessage,
		touched
	});

	$$self.$inject_state = $$props => {
		if ('controlType' in $$props) $$invalidate(1, controlType = $$props.controlType);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
		if ('valid' in $$props) $$invalidate(6, valid = $$props.valid);
		if ('validityMessage' in $$props) $$invalidate(7, validityMessage = $$props.validityMessage);
		if ('touched' in $$props) $$invalidate(8, touched = $$props.touched);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		value,
		controlType,
		id,
		label,
		type,
		rows,
		valid,
		validityMessage,
		touched,
		input_handler,
		textarea_input_handler,
		blur_handler,
		blur_handler_1
	];
}

class TextInput extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			controlType: 1,
			id: 2,
			label: 3,
			type: 4,
			value: 0,
			rows: 5,
			valid: 6,
			validityMessage: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextInput",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[2] === undefined && !('id' in props)) {
			console.warn("<TextInput> was created without expected prop 'id'");
		}

		if (/*label*/ ctx[3] === undefined && !('label' in props)) {
			console.warn("<TextInput> was created without expected prop 'label'");
		}

		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
			console.warn("<TextInput> was created without expected prop 'value'");
		}

		if (/*validityMessage*/ ctx[7] === undefined && !('validityMessage' in props)) {
			console.warn("<TextInput> was created without expected prop 'validityMessage'");
		}
	}

	get controlType() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set controlType(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validityMessage() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validityMessage(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\Meetup\EditMeetup.svelte generated by Svelte v3.44.3 */

const { Error: Error_1$1, console: console_1$1 } = globals;
const file$2 = "src\\components\\Meetup\\EditMeetup.svelte";

// (142:0) {#if error}
function create_if_block_1$1(ctx) {
	let error_1;
	let current;

	error_1 = new Error$1({
			props: { message: /*error*/ ctx[13].message },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(error_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(error_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const error_1_changes = {};
			if (dirty & /*error*/ 8192) error_1_changes.message = /*error*/ ctx[13].message;
			error_1.$set(error_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(error_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(142:0) {#if error}",
		ctx
	});

	return block;
}

// (146:0) <Modal title="Edit Meetup Data" on:cancel>
function create_default_slot_3(ctx) {
	let form;
	let textinput0;
	let t0;
	let textinput1;
	let t1;
	let textinput2;
	let t2;
	let textinput3;
	let t3;
	let textinput4;
	let t4;
	let textinput5;
	let updating_value;
	let current;
	let mounted;
	let dispose;

	textinput0 = new TextInput({
			props: {
				id: "title",
				label: "Title",
				value: /*title*/ ctx[1],
				valid: /*titleValid*/ ctx[12],
				validityMessage: "Please enter a valid title."
			},
			$$inline: true
		});

	textinput0.$on("input", /*input_handler*/ ctx[18]);

	textinput1 = new TextInput({
			props: {
				id: "subtitle",
				label: "Sub Title",
				value: /*subtitle*/ ctx[2],
				valid: /*subtitleValid*/ ctx[11],
				validityMessage: "Please enter a valid subtitle."
			},
			$$inline: true
		});

	textinput1.$on("input", /*input_handler_1*/ ctx[19]);

	textinput2 = new TextInput({
			props: {
				id: "address",
				label: "Address",
				value: /*address*/ ctx[3],
				valid: /*addressValid*/ ctx[10],
				validityMessage: "Please enter a valid address."
			},
			$$inline: true
		});

	textinput2.$on("input", /*input_handler_2*/ ctx[20]);

	textinput3 = new TextInput({
			props: {
				id: "imageURL",
				label: "Image URL",
				value: /*imageURL*/ ctx[4],
				valid: /*imageURLValid*/ ctx[9],
				validityMessage: "Please enter a valid image url."
			},
			$$inline: true
		});

	textinput3.$on("input", /*input_handler_3*/ ctx[21]);

	textinput4 = new TextInput({
			props: {
				id: "email",
				label: "E-Mail",
				type: "email",
				value: /*email*/ ctx[5],
				valid: /*emailValid*/ ctx[7],
				validityMessage: "Please enter a valid email address."
			},
			$$inline: true
		});

	textinput4.$on("input", /*input_handler_4*/ ctx[22]);

	function textinput5_value_binding(value) {
		/*textinput5_value_binding*/ ctx[23](value);
	}

	let textinput5_props = {
		id: "description",
		label: "Description",
		controlType: "textarea",
		valid: /*descriptionValid*/ ctx[8],
		validityMessage: "Please enter a valid description."
	};

	if (/*description*/ ctx[6] !== void 0) {
		textinput5_props.value = /*description*/ ctx[6];
	}

	textinput5 = new TextInput({ props: textinput5_props, $$inline: true });
	binding_callbacks.push(() => bind(textinput5, 'value', textinput5_value_binding));

	const block = {
		c: function create() {
			form = element("form");
			create_component(textinput0.$$.fragment);
			t0 = space();
			create_component(textinput1.$$.fragment);
			t1 = space();
			create_component(textinput2.$$.fragment);
			t2 = space();
			create_component(textinput3.$$.fragment);
			t3 = space();
			create_component(textinput4.$$.fragment);
			t4 = space();
			create_component(textinput5.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			claim_component(textinput0.$$.fragment, form_nodes);
			t0 = claim_space(form_nodes);
			claim_component(textinput1.$$.fragment, form_nodes);
			t1 = claim_space(form_nodes);
			claim_component(textinput2.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(textinput3.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			claim_component(textinput4.$$.fragment, form_nodes);
			t4 = claim_space(form_nodes);
			claim_component(textinput5.$$.fragment, form_nodes);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form, "class", "svelte-no1xoc");
			add_location(form, file$2, 146, 2, 3548);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, form, anchor);
			mount_component(textinput0, form, null);
			append_hydration_dev(form, t0);
			mount_component(textinput1, form, null);
			append_hydration_dev(form, t1);
			mount_component(textinput2, form, null);
			append_hydration_dev(form, t2);
			mount_component(textinput3, form, null);
			append_hydration_dev(form, t3);
			mount_component(textinput4, form, null);
			append_hydration_dev(form, t4);
			mount_component(textinput5, form, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*submitForm*/ ctx[15]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textinput0_changes = {};
			if (dirty & /*title*/ 2) textinput0_changes.value = /*title*/ ctx[1];
			if (dirty & /*titleValid*/ 4096) textinput0_changes.valid = /*titleValid*/ ctx[12];
			textinput0.$set(textinput0_changes);
			const textinput1_changes = {};
			if (dirty & /*subtitle*/ 4) textinput1_changes.value = /*subtitle*/ ctx[2];
			if (dirty & /*subtitleValid*/ 2048) textinput1_changes.valid = /*subtitleValid*/ ctx[11];
			textinput1.$set(textinput1_changes);
			const textinput2_changes = {};
			if (dirty & /*address*/ 8) textinput2_changes.value = /*address*/ ctx[3];
			if (dirty & /*addressValid*/ 1024) textinput2_changes.valid = /*addressValid*/ ctx[10];
			textinput2.$set(textinput2_changes);
			const textinput3_changes = {};
			if (dirty & /*imageURL*/ 16) textinput3_changes.value = /*imageURL*/ ctx[4];
			if (dirty & /*imageURLValid*/ 512) textinput3_changes.valid = /*imageURLValid*/ ctx[9];
			textinput3.$set(textinput3_changes);
			const textinput4_changes = {};
			if (dirty & /*email*/ 32) textinput4_changes.value = /*email*/ ctx[5];
			if (dirty & /*emailValid*/ 128) textinput4_changes.valid = /*emailValid*/ ctx[7];
			textinput4.$set(textinput4_changes);
			const textinput5_changes = {};
			if (dirty & /*descriptionValid*/ 256) textinput5_changes.valid = /*descriptionValid*/ ctx[8];

			if (!updating_value && dirty & /*description*/ 64) {
				updating_value = true;
				textinput5_changes.value = /*description*/ ctx[6];
				add_flush_callback(() => updating_value = false);
			}

			textinput5.$set(textinput5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textinput0.$$.fragment, local);
			transition_in(textinput1.$$.fragment, local);
			transition_in(textinput2.$$.fragment, local);
			transition_in(textinput3.$$.fragment, local);
			transition_in(textinput4.$$.fragment, local);
			transition_in(textinput5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textinput0.$$.fragment, local);
			transition_out(textinput1.$$.fragment, local);
			transition_out(textinput2.$$.fragment, local);
			transition_out(textinput3.$$.fragment, local);
			transition_out(textinput4.$$.fragment, local);
			transition_out(textinput5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_component(textinput0);
			destroy_component(textinput1);
			destroy_component(textinput2);
			destroy_component(textinput3);
			destroy_component(textinput4);
			destroy_component(textinput5);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(146:0) <Modal title=\\\"Edit Meetup Data\\\" on:cancel>",
		ctx
	});

	return block;
}

// (200:4) <Button mode="outline" type="button" on:click={cancel}>
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cancel");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(200:4) <Button mode=\\\"outline\\\" type=\\\"button\\\" on:click={cancel}>",
		ctx
	});

	return block;
}

// (201:4) <Button type="button" on:click={submitForm} disabled={!isFormValid}        >
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Save");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(201:4) <Button type=\\\"button\\\" on:click={submitForm} disabled={!isFormValid}        >",
		ctx
	});

	return block;
}

// (204:4) {#if id}
function create_if_block$1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "button",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*deleteMeetup*/ ctx[17]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(204:4) {#if id}",
		ctx
	});

	return block;
}

// (205:6) <Button type="button" on:click={deleteMeetup}>
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(205:6) <Button type=\\\"button\\\" on:click={deleteMeetup}>",
		ctx
	});

	return block;
}

// (199:2) 
function create_footer_slot(ctx) {
	let div;
	let button0;
	let t0;
	let button1;
	let t1;
	let current;

	button0 = new Button({
			props: {
				mode: "outline",
				type: "button",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*cancel*/ ctx[16]);

	button1 = new Button({
			props: {
				type: "button",
				disabled: !/*isFormValid*/ ctx[14],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*submitForm*/ ctx[15]);
	let if_block = /*id*/ ctx[0] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(button0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(button1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "footer");
			add_location(div, file$2, 198, 2, 4982);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_hydration_dev(div, t0);
			mount_component(button1, div, null);
			append_hydration_dev(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*isFormValid*/ 16384) button1_changes.disabled = !/*isFormValid*/ ctx[14];

			if (dirty & /*$$scope*/ 134217728) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);

			if (/*id*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*id*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(199:2) ",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let t;
	let modal;
	let current;
	let if_block = /*error*/ ctx[13] && create_if_block_1$1(ctx);

	modal = new Modal({
			props: {
				title: "Edit Meetup Data",
				$$slots: {
					footer: [create_footer_slot],
					default: [create_default_slot_3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	modal.$on("cancel", /*cancel_handler*/ ctx[24]);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(modal.$$.fragment);
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			claim_component(modal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, t, anchor);
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*error*/ ctx[13]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*error*/ 8192) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const modal_changes = {};

			if (dirty & /*$$scope, id, isFormValid, descriptionValid, description, email, emailValid, imageURL, imageURLValid, address, addressValid, subtitle, subtitleValid, title, titleValid*/ 134242303) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let titleValid;
	let subtitleValid;
	let addressValid;
	let imageURLValid;
	let descriptionValid;
	let emailValid;
	let isFormValid;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditMeetup', slots, []);
	let { id } = $$props;
	let title = '';
	let subtitle = '';
	let address = '';
	let imageURL = '';
	let email = '';
	let description = '';
	let error;

	if (id) {
		const unsuscribe = customMeetupStore.subscribe(items => {
			const selectedMeetup = items.find(i => i.id === id);
			$$invalidate(1, title = selectedMeetup.title);
			$$invalidate(2, subtitle = selectedMeetup.subtitle);
			$$invalidate(3, address = selectedMeetup.address);
			$$invalidate(4, imageURL = selectedMeetup.imageURL);
			$$invalidate(5, email = selectedMeetup.contactEmail);
			$$invalidate(6, description = selectedMeetup.description);
		});

		unsuscribe();
	}

	let dispatch = createEventDispatcher();

	function submitForm() {
		const meetupData = {
			title,
			subtitle,
			description,
			imageURL,
			address,
			contactEmail: email
		};

		if (id) {
			fetch(`https://meetups-e2e4b-default-rtdb.firebaseio.com/meetups/${id}.json`, {
				method: 'PATCH',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(meetupData)
			}).then(res => {
				if (!res.ok) {
					throw new Error$1('Failed!');
				}

				customMeetupStore.updateMeetup(id, meetupData);
			}).catch(err => {
				$$invalidate(13, error = err);
				console.log(err);
			});
		} else {
			fetch('https://meetups-e2e4b-default-rtdb.firebaseio.com/meetups.json', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ ...meetupData, isFavorite: false })
			}).then(res => {
				if (!res.ok) {
					throw new Error$1('Failed!');
				}

				return res.json();
			}).then(data => {
				customMeetupStore.addMeetup({
					...meetupData,
					isFavorite: false,
					id: data.name
				});
			}).catch(err => {
				$$invalidate(13, error = err);
				console.log(err);
			});
		}

		dispatch('save');
	}

	function cancel() {
		dispatch('cancel');
	}

	function deleteMeetup() {
		fetch(`https://meetups-e2e4b-default-rtdb.firebaseio.com/meetups/${id}.json`, { method: 'DELETE' }).then(res => {
			if (!res.ok) {
				throw new Error$1('Failed!');
			}

			customMeetupStore.deleteMeetup(id);
		}).catch(err => {
			$$invalidate(13, error = err);
			console.log(err);
		});

		dispatch('save');
	}

	function clearError() {
		$$invalidate(13, error = null);
	}

	const writable_props = ['id'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<EditMeetup> was created with unknown prop '${key}'`);
	});

	const input_handler = e => $$invalidate(1, title = e.target.value);
	const input_handler_1 = e => $$invalidate(2, subtitle = e.target.value);
	const input_handler_2 = e => $$invalidate(3, address = e.target.value);
	const input_handler_3 = e => $$invalidate(4, imageURL = e.target.value);
	const input_handler_4 = e => $$invalidate(5, email = e.target.value);

	function textinput5_value_binding(value) {
		description = value;
		$$invalidate(6, description);
	}

	function cancel_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
	};

	$$self.$capture_state = () => ({
		meetups: customMeetupStore,
		createEventDispatcher,
		isEmpty,
		isValidEmail,
		Modal,
		Button,
		TextInput,
		Error: Error$1,
		id,
		title,
		subtitle,
		address,
		imageURL,
		email,
		description,
		error,
		dispatch,
		submitForm,
		cancel,
		deleteMeetup,
		clearError,
		emailValid,
		descriptionValid,
		imageURLValid,
		addressValid,
		subtitleValid,
		titleValid,
		isFormValid
	});

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
		if ('address' in $$props) $$invalidate(3, address = $$props.address);
		if ('imageURL' in $$props) $$invalidate(4, imageURL = $$props.imageURL);
		if ('email' in $$props) $$invalidate(5, email = $$props.email);
		if ('description' in $$props) $$invalidate(6, description = $$props.description);
		if ('error' in $$props) $$invalidate(13, error = $$props.error);
		if ('dispatch' in $$props) dispatch = $$props.dispatch;
		if ('emailValid' in $$props) $$invalidate(7, emailValid = $$props.emailValid);
		if ('descriptionValid' in $$props) $$invalidate(8, descriptionValid = $$props.descriptionValid);
		if ('imageURLValid' in $$props) $$invalidate(9, imageURLValid = $$props.imageURLValid);
		if ('addressValid' in $$props) $$invalidate(10, addressValid = $$props.addressValid);
		if ('subtitleValid' in $$props) $$invalidate(11, subtitleValid = $$props.subtitleValid);
		if ('titleValid' in $$props) $$invalidate(12, titleValid = $$props.titleValid);
		if ('isFormValid' in $$props) $$invalidate(14, isFormValid = $$props.isFormValid);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title*/ 2) {
			$$invalidate(12, titleValid = !isEmpty(title));
		}

		if ($$self.$$.dirty & /*subtitle*/ 4) {
			$$invalidate(11, subtitleValid = !isEmpty(subtitle));
		}

		if ($$self.$$.dirty & /*address*/ 8) {
			$$invalidate(10, addressValid = !isEmpty(address));
		}

		if ($$self.$$.dirty & /*imageURL*/ 16) {
			$$invalidate(9, imageURLValid = !isEmpty(imageURL));
		}

		if ($$self.$$.dirty & /*description*/ 64) {
			$$invalidate(8, descriptionValid = !isEmpty(description));
		}

		if ($$self.$$.dirty & /*email*/ 32) {
			$$invalidate(7, emailValid = isValidEmail(email));
		}

		if ($$self.$$.dirty & /*titleValid, subtitleValid, addressValid, imageURLValid, descriptionValid, emailValid*/ 8064) {
			$$invalidate(14, isFormValid = titleValid && subtitleValid && addressValid && imageURLValid && descriptionValid && emailValid);
		}
	};

	return [
		id,
		title,
		subtitle,
		address,
		imageURL,
		email,
		description,
		emailValid,
		descriptionValid,
		imageURLValid,
		addressValid,
		subtitleValid,
		titleValid,
		error,
		isFormValid,
		submitForm,
		cancel,
		deleteMeetup,
		input_handler,
		input_handler_1,
		input_handler_2,
		input_handler_3,
		input_handler_4,
		textinput5_value_binding,
		cancel_handler
	];
}

class EditMeetup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditMeetup",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !('id' in props)) {
			console_1$1.warn("<EditMeetup> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error_1$1("<EditMeetup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error_1$1("<EditMeetup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\UI\LoadingSpinner.svelte generated by Svelte v3.44.3 */

const file$1 = "src\\components\\UI\\LoadingSpinner.svelte";

function create_fragment$1(ctx) {
	let div5;
	let div4;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let t2;
	let div3;

	const block = {
		c: function create() {
			div5 = element("div");
			div4 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			t2 = space();
			div3 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			children(div2).forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			children(div3).forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "svelte-9m1hb2");
			add_location(div0, file$1, 2, 4, 53);
			attr_dev(div1, "class", "svelte-9m1hb2");
			add_location(div1, file$1, 3, 4, 66);
			attr_dev(div2, "class", "svelte-9m1hb2");
			add_location(div2, file$1, 4, 4, 79);
			attr_dev(div3, "class", "svelte-9m1hb2");
			add_location(div3, file$1, 5, 4, 92);
			attr_dev(div4, "class", "lds-ring svelte-9m1hb2");
			add_location(div4, file$1, 1, 2, 25);
			attr_dev(div5, "class", "loading svelte-9m1hb2");
			add_location(div5, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div5, anchor);
			append_hydration_dev(div5, div4);
			append_hydration_dev(div4, div0);
			append_hydration_dev(div4, t0);
			append_hydration_dev(div4, div1);
			append_hydration_dev(div4, t1);
			append_hydration_dev(div4, div2);
			append_hydration_dev(div4, t2);
			append_hydration_dev(div4, div3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LoadingSpinner', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingSpinner> was created with unknown prop '${key}'`);
	});

	return [];
}

class LoadingSpinner extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadingSpinner",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src\routes\index.svelte generated by Svelte v3.44.3 */

const { Error: Error_1, console: console_1 } = globals;
const file = "src\\routes\\index.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

// (104:0) {#if editMode === 'edit'}
function create_if_block_2(ctx) {
	let editmeetup;
	let current;

	editmeetup = new EditMeetup({
			props: { id: /*editedId*/ ctx[1] },
			$$inline: true
		});

	editmeetup.$on("save", /*savedMeetup*/ ctx[5]);
	editmeetup.$on("cancel", /*cancelEdit*/ ctx[6]);

	const block = {
		c: function create() {
			create_component(editmeetup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editmeetup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editmeetup, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editmeetup_changes = {};
			if (dirty & /*editedId*/ 2) editmeetup_changes.id = /*editedId*/ ctx[1];
			editmeetup.$set(editmeetup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editmeetup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editmeetup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editmeetup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(104:0) {#if editMode === 'edit'}",
		ctx
	});

	return block;
}

// (109:0) {:else}
function create_else_block(ctx) {
	let section;
	let meetupfilter;
	let t0;
	let button;
	let t1;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	meetupfilter = new MeetupFilter({ $$inline: true });
	meetupfilter.$on("select", /*filterMeetup*/ ctx[4]);

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*setAdd*/ ctx[8]);
	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*filteredMeetups*/ ctx[2].length === 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			create_component(meetupfilter.$$.fragment);
			t0 = space();
			create_component(button.$$.fragment);
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { id: true, class: true });
			var section_nodes = children(section);
			claim_component(meetupfilter.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			claim_component(button.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "id", "meetup-controls");
			attr_dev(section, "class", "svelte-18e9u1f");
			add_location(section, file, 109, 2, 2655);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);
			mount_component(meetupfilter, section, null);
			append_hydration_dev(section, t0);
			mount_component(button, section, null);
			insert_hydration_dev(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(meetupfilter.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(meetupfilter.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(meetupfilter);
			destroy_component(button);
			if (detaching) detach_dev(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(109:0) {:else}",
		ctx
	});

	return block;
}

// (107:0) {#if isLoading}
function create_if_block(ctx) {
	let loadingspinner;
	let current;
	loadingspinner = new LoadingSpinner({ $$inline: true });

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loadingspinner.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(107:0) {#if isLoading}",
		ctx
	});

	return block;
}

// (112:4) <Button on:click={setAdd}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("New Meetup");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "New Meetup");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(112:4) <Button on:click={setAdd}>",
		ctx
	});

	return block;
}

// (117:2) {:else}
function create_else_block_1(ctx) {
	let section;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*filteredMeetups*/ ctx[2];
	validate_each_argument(each_value);
	const get_key = ctx => /*meetup*/ ctx[13].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			section = element("section");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { id: true, class: true });
			var section_nodes = children(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(section_nodes);
			}

			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "id", "meetups");
			attr_dev(section, "class", "svelte-18e9u1f");
			add_location(section, file, 117, 4, 2924);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(section, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*filteredMeetups, startEdit*/ 132) {
				each_value = /*filteredMeetups*/ ctx[2];
				validate_each_argument(each_value);
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, section, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(117:2) {:else}",
		ctx
	});

	return block;
}

// (115:2) {#if filteredMeetups.length === 0}
function create_if_block_1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("No meetups yet, start by adding some.");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, "No meetups yet, start by adding some.");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", "no-meetups");
			attr_dev(div, "class", "svelte-18e9u1f");
			add_location(div, file, 115, 4, 2843);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(115:2) {#if filteredMeetups.length === 0}",
		ctx
	});

	return block;
}

// (119:6) {#each filteredMeetups as meetup (meetup.id)}
function create_each_block(key_1, ctx) {
	let div;
	let meetupitem;
	let t;
	let div_intro;
	let rect;
	let stop_animation = noop;
	let current;

	meetupitem = new MeetupItem({
			props: {
				id: /*meetup*/ ctx[13].id,
				title: /*meetup*/ ctx[13].title,
				subtitle: /*meetup*/ ctx[13].subtitle,
				description: /*meetup*/ ctx[13].description,
				imageURL: /*meetup*/ ctx[13].imageURL,
				address: /*meetup*/ ctx[13].address,
				email: /*meetup*/ ctx[13].contactEmail,
				isFav: /*meetup*/ ctx[13].isFavorite
			},
			$$inline: true
		});

	meetupitem.$on("edit", /*startEdit*/ ctx[7]);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = element("div");
			create_component(meetupitem.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(meetupitem.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file, 119, 8, 3009);
			this.first = div;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(meetupitem, div, null);
			append_hydration_dev(div, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const meetupitem_changes = {};
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.id = /*meetup*/ ctx[13].id;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.title = /*meetup*/ ctx[13].title;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.subtitle = /*meetup*/ ctx[13].subtitle;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.description = /*meetup*/ ctx[13].description;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.imageURL = /*meetup*/ ctx[13].imageURL;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.address = /*meetup*/ ctx[13].address;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.email = /*meetup*/ ctx[13].contactEmail;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.isFav = /*meetup*/ ctx[13].isFavorite;
			meetupitem.$set(meetupitem_changes);
		},
		r: function measure() {
			rect = div.getBoundingClientRect();
		},
		f: function fix() {
			fix_position(div);
			stop_animation();
		},
		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div, rect, flip, { duration: 300 });
		},
		i: function intro(local) {
			if (current) return;
			transition_in(meetupitem.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, scale, {});
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(meetupitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(meetupitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(119:6) {#each filteredMeetups as meetup (meetup.id)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let t1;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*editMode*/ ctx[0] === 'edit' && create_if_block_2(ctx);
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-jjer0t\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			document.title = "All Meetups";
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*editMode*/ ctx[0] === 'edit') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*editMode*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload(page) {
	return this.fetch('https://meetups-e2e4b-default-rtdb.firebaseio.com/meetups.json').then(res => {
		if (!res.ok) {
			throw new Error('Fetching meetups failed, please try again later!');
		}

		return res.json();
	}).then(data => {
		const fetchedMeetups = [];

		for (const key in data) {
			fetchedMeetups.push({ ...data[key], id: key });
		}

		return { fetchedMeetups: fetchedMeetups.reverse() };
	}).// }, 1000);
	catch(err => {
		error = err; // setTimeout(() => {
		//   isLoading = false;
		//   meetups.setMeetups(fetchedMeetups.reverse());

		isLoading = false;
		console.log(err);
		this.error(500, 'Could not load meetups!');
	});
}

function instance($$self, $$props, $$invalidate) {
	let filteredMeetups;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Routes', slots, []);
	let { fetchedMeetups } = $$props;
	let editMode;
	let editedId;
	let isLoading;
	let unsubscribe;
	const dispatch = createEventDispatcher();
	let favsOnly = false;

	onMount(() => {
		customMeetupStore.setMeetups(fetchedMeetups);

		unsubscribe = customMeetupStore.subscribe(items => {
			$$invalidate(9, fetchedMeetups = items);
		});
	});

	onDestroy(() => {
		if (unsubscribe) {
			unsubscribe();
		}
	});

	function filterMeetup(event) {
		$$invalidate(10, favsOnly = event.detail === 1);
	}

	function savedMeetup(event) {
		$$invalidate(0, editMode = null);
		$$invalidate(1, editedId = null);
	}

	function cancelEdit() {
		$$invalidate(0, editMode = null);
		$$invalidate(1, editedId = null);
	}

	function startEdit(event) {
		$$invalidate(0, editMode = 'edit');
		$$invalidate(1, editedId = event.detail);
	}

	function setAdd() {
		$$invalidate(0, editMode = 'edit');
	}

	const writable_props = ['fetchedMeetups'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('fetchedMeetups' in $$props) $$invalidate(9, fetchedMeetups = $$props.fetchedMeetups);
	};

	$$self.$capture_state = () => ({
		preload,
		createEventDispatcher,
		onMount,
		onDestroy,
		scale,
		flip,
		meetups: customMeetupStore,
		MeetupItem,
		MeetupFilter,
		Button,
		EditMeetup,
		LoadingSpinner,
		fetchedMeetups,
		editMode,
		editedId,
		isLoading,
		unsubscribe,
		dispatch,
		favsOnly,
		filterMeetup,
		savedMeetup,
		cancelEdit,
		startEdit,
		setAdd,
		filteredMeetups
	});

	$$self.$inject_state = $$props => {
		if ('fetchedMeetups' in $$props) $$invalidate(9, fetchedMeetups = $$props.fetchedMeetups);
		if ('editMode' in $$props) $$invalidate(0, editMode = $$props.editMode);
		if ('editedId' in $$props) $$invalidate(1, editedId = $$props.editedId);
		if ('isLoading' in $$props) $$invalidate(3, isLoading = $$props.isLoading);
		if ('unsubscribe' in $$props) unsubscribe = $$props.unsubscribe;
		if ('favsOnly' in $$props) $$invalidate(10, favsOnly = $$props.favsOnly);
		if ('filteredMeetups' in $$props) $$invalidate(2, filteredMeetups = $$props.filteredMeetups);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*favsOnly, fetchedMeetups*/ 1536) {
			$$invalidate(2, filteredMeetups = favsOnly
			? fetchedMeetups.filter(m => m.isFavorite)
			: fetchedMeetups);
		}
	};

	return [
		editMode,
		editedId,
		filteredMeetups,
		isLoading,
		filterMeetup,
		savedMeetup,
		cancelEdit,
		startEdit,
		setAdd,
		fetchedMeetups,
		favsOnly
	];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { fetchedMeetups: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*fetchedMeetups*/ ctx[9] === undefined && !('fetchedMeetups' in props)) {
			console_1.warn("<Routes> was created without expected prop 'fetchedMeetups'");
		}
	}

	get fetchedMeetups() {
		throw new Error_1("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fetchedMeetups(value) {
		throw new Error_1("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Routes as default, preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNDQzNWY1ZGUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvYW5pbWF0ZS9pbmRleC5tanMiLCIuLi8uLi8uLi9zcmMvbWVldHVwcy1zdG9yZS5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VJL0JhZGdlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VJL01vZGFsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VJL0Vycm9yLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01lZXR1cC9NZWV0dXBJdGVtLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01lZXR1cC9NZWV0dXBGaWx0ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2hlbHBlcnMvdmFsaWRhdGlvbi5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VJL1RleHRJbnB1dC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9NZWV0dXAvRWRpdE1lZXR1cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9VSS9Mb2FkaW5nU3Bpbm5lci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBmbGlwKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBbb3gsIG95XSA9IHN0eWxlLnRyYW5zZm9ybU9yaWdpbi5zcGxpdCgnICcpLm1hcChwYXJzZUZsb2F0KTtcbiAgICBjb25zdCBkeCA9IChmcm9tLmxlZnQgKyBmcm9tLndpZHRoICogb3ggLyB0by53aWR0aCkgLSAodG8ubGVmdCArIG94KTtcbiAgICBjb25zdCBkeSA9IChmcm9tLnRvcCArIGZyb20uaGVpZ2h0ICogb3kgLyB0by5oZWlnaHQpIC0gKHRvLnRvcCArIG95KTtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAoZCkgPT4gTWF0aC5zcXJ0KGQpICogMTIwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSkgOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdSAqIGR4O1xuICAgICAgICAgICAgY29uc3QgeSA9IHUgKiBkeTtcbiAgICAgICAgICAgIGNvbnN0IHN4ID0gdCArIHUgKiBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBzeSA9IHQgKyB1ICogZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gYHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weCkgc2NhbGUoJHtzeH0sICR7c3l9KTtgO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgZmxpcCB9O1xuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xyXG5cclxuY29uc3QgbWVldHVwcyA9IHdyaXRhYmxlKFtdKTtcclxuXHJcbmNvbnN0IGN1c3RvbU1lZXR1cFN0b3JlID0ge1xyXG4gIHN1YnNjcmliZTogbWVldHVwcy5zdWJzY3JpYmUsXHJcbiAgc2V0TWVldHVwczogKG1lZXR1cEFycmF5KSA9PiB7XHJcbiAgICBtZWV0dXBzLnNldChtZWV0dXBBcnJheSk7XHJcbiAgfSxcclxuICBhZGRNZWV0dXA6IChtZWV0dXBEYXRhKSA9PiB7XHJcbiAgICBjb25zdCBuZXdNZWV0dXAgPSB7XHJcbiAgICAgIC4uLm1lZXR1cERhdGEsXHJcbiAgICB9O1xyXG5cclxuICAgIG1lZXR1cHMudXBkYXRlKChpdGVtcykgPT4ge1xyXG4gICAgICByZXR1cm4gW25ld01lZXR1cCwgLi4uaXRlbXNdO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICB1cGRhdGVNZWV0dXA6IChpZCwgbWVldHVwRGF0YSkgPT4ge1xyXG4gICAgbWVldHVwcy51cGRhdGUoKGl0ZW1zKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1lZXR1cEluZGV4ID0gaXRlbXMuZmluZEluZGV4KChpKSA9PiBpLmlkID09PSBpZCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRNZWV0dXAgPSB7IC4uLml0ZW1zW21lZXR1cEluZGV4XSwgLi4ubWVldHVwRGF0YSB9O1xyXG4gICAgICBjb25zdCB1cGRhdGVkTWVldHVwcyA9IFsuLi5pdGVtc107XHJcbiAgICAgIHVwZGF0ZWRNZWV0dXBzW21lZXR1cEluZGV4XSA9IHVwZGF0ZWRNZWV0dXA7XHJcblxyXG4gICAgICByZXR1cm4gdXBkYXRlZE1lZXR1cHM7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGRlbGV0ZU1lZXR1cDogKGlkKSA9PiB7XHJcbiAgICBtZWV0dXBzLnVwZGF0ZSgoaXRlbXMpID0+IHtcclxuICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaSkgPT4gaS5pZCAhPT0gaWQpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICB0b2dnbGVGYXZvcml0ZTogKGlkKSA9PiB7XHJcbiAgICBtZWV0dXBzLnVwZGF0ZSgoaXRlbXMpID0+IHtcclxuICAgICAgY29uc3QgdXBkYXRlZE1lZXR1cCA9IHsgLi4uaXRlbXMuZmluZCgobSkgPT4gbS5pZCA9PT0gaWQpIH07XHJcbiAgICAgIHVwZGF0ZWRNZWV0dXAuaXNGYXZvcml0ZSA9ICF1cGRhdGVkTWVldHVwLmlzRmF2b3JpdGU7XHJcblxyXG4gICAgICBjb25zdCBtZWV0dXBJbmRleCA9IGl0ZW1zLmZpbmRJbmRleCgobSkgPT4gbS5pZCA9PT0gaWQpO1xyXG4gICAgICBjb25zdCB1cGRhdGVkTWVldHVwcyA9IFsuLi5pdGVtc107XHJcblxyXG4gICAgICB1cGRhdGVkTWVldHVwc1ttZWV0dXBJbmRleF0gPSB1cGRhdGVkTWVldHVwO1xyXG4gICAgICByZXR1cm4gdXBkYXRlZE1lZXR1cHM7XHJcbiAgICB9KTtcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY3VzdG9tTWVldHVwU3RvcmU7XHJcbiIsIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHNwYW4gdHJhbnNpdGlvbjpzbGlkZT5cclxuICA8c2xvdCAvPlxyXG48L3NwYW4+XHJcblxyXG48c3R5bGU+XHJcbiAgc3BhbiB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBtYXJnaW46IDAgMC4yNXJlbTtcclxuICAgIHBhZGRpbmc6IDAgMC41cmVtO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NmMDA1NjtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNjZjAwNTY7XHJcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBmb250LXNpemU6IDAuOHJlbTtcclxuICAgIGZvbnQtZmFtaWx5OiAnTGF0bycsIHNhbnMtc2VyaWY7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24uc3ZlbHRlJztcclxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xyXG4gIGltcG9ydCB7IGZhZGUsIGZseSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcclxuXHJcbiAgZXhwb3J0IGxldCB0aXRsZTtcclxuXHJcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbE1vZGFsKCkge1xyXG4gICAgZGlzcGF0Y2goJ2NhbmNlbCcpO1xyXG4gIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IHRyYW5zaXRpb246ZmFkZSBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wXCIgb246Y2xpY2s9e2NhbmNlbE1vZGFsfSAvPlxyXG48ZGl2IHRyYW5zaXRpb246Zmx5PXt7IHk6IDMwMCB9fSBjbGFzcz1cIm1vZGFsXCI+XHJcbiAgPGgxPnt0aXRsZX08L2gxPlxyXG4gIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICA8c2xvdCAvPlxyXG4gIDwvZGl2PlxyXG4gIDxmb290ZXI+XHJcbiAgICA8c2xvdCBuYW1lPVwiZm9vdGVyXCI+XHJcbiAgICAgIDxCdXR0b24gb246Y2xpY2s9e2NhbmNlbE1vZGFsfT5DbG9zZTwvQnV0dG9uPlxyXG4gICAgPC9zbG90PlxyXG4gIDwvZm9vdGVyPlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAubW9kYWwtYmFja2Ryb3Age1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgdG9wOiAwO1xyXG4gICAgbGVmdDogMDtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43NSk7XHJcbiAgICB6LWluZGV4OiAxMDtcclxuICB9XHJcblxyXG4gIC5tb2RhbCB7XHJcbiAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICB0b3A6IDEwdmg7XHJcbiAgICBsZWZ0OiAxMCU7XHJcbiAgICB3aWR0aDogODAlO1xyXG4gICAgbWF4LWhlaWdodDogODB2aDtcclxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gICAgei1pbmRleDogMTAwO1xyXG4gICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yNik7XHJcbiAgICBvdmVyZmxvdzogc2Nyb2xsO1xyXG4gIH1cclxuXHJcbiAgaDEge1xyXG4gICAgcGFkZGluZzogMXJlbTtcclxuICAgIG1hcmdpbjogMDtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xyXG4gICAgZm9udC1mYW1pbHk6ICdSb2JvdG8gU2xhYicsIHNhbnMtc2VyaWY7XHJcbiAgfVxyXG5cclxuICAuY29udGVudCB7XHJcbiAgICBwYWRkaW5nOiAxcmVtO1xyXG4gIH1cclxuXHJcbiAgZm9vdGVyIHtcclxuICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgfVxyXG5cclxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcclxuICAgIC5tb2RhbCB7XHJcbiAgICAgIHdpZHRoOiA0MHJlbTtcclxuICAgICAgbGVmdDogY2FsYyg1MCUgLSAyMHJlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCBNb2RhbCBmcm9tICcuL01vZGFsLnN2ZWx0ZSc7XHJcblxyXG4gIGV4cG9ydCBsZXQgbWVzc2FnZTtcclxuPC9zY3JpcHQ+XHJcblxyXG48TW9kYWwgdGl0bGU9XCJBbiBlcnJvciBvY2N1cmVkIVwiIG9uOmNhbmNlbD5cclxuICA8cD57bWVzc2FnZX08L3A+XHJcbjwvTW9kYWw+XHJcbiIsIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IG1lZXR1cHMgZnJvbSAnLi4vLi4vbWVldHVwcy1zdG9yZSc7XHJcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9VSS9CdXR0b24uc3ZlbHRlJztcclxuICBpbXBvcnQgQmFkZ2UgZnJvbSAnLi4vVUkvQmFkZ2Uuc3ZlbHRlJztcclxuICBpbXBvcnQgRXJyb3IgZnJvbSAnLi4vVUkvRXJyb3Iuc3ZlbHRlJztcclxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuICBleHBvcnQgbGV0IGlkO1xyXG4gIGV4cG9ydCBsZXQgdGl0bGU7XHJcbiAgZXhwb3J0IGxldCBzdWJ0aXRsZTtcclxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uO1xyXG4gIGV4cG9ydCBsZXQgaW1hZ2VVUkw7XHJcbiAgZXhwb3J0IGxldCBhZGRyZXNzO1xyXG4gIGV4cG9ydCBsZXQgaXNGYXY7XHJcblxyXG4gIGxldCBlcnJvcjtcclxuXHJcbiAgbGV0IGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlRmF2b3JpdGUoKSB7XHJcbiAgICBpc0xvYWRpbmcgPSB0cnVlO1xyXG4gICAgZmV0Y2goXHJcbiAgICAgIGBodHRwczovL21lZXR1cHMtZTJlNGItZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tL21lZXR1cHMvJHtpZH0uanNvbmAsXHJcbiAgICAgIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNGYXZvcml0ZTogIWlzRmF2IH0pLFxyXG4gICAgICB9XHJcbiAgICApXHJcbiAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZWV0dXBzLnRvZ2dsZUZhdm9yaXRlKGlkKTtcclxuICAgICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICBlcnJvciA9IGVycjtcclxuICAgICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3IoKSB7XHJcbiAgICBlcnJvciA9IG51bGw7XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbnsjaWYgZXJyb3J9XHJcbiAgPEVycm9yIG1lc3NhZ2U9e2Vycm9yLm1lc3NhZ2V9IG9uOmNhbmNlbD17Y2xlYXJFcnJvcn0gLz5cclxuey9pZn1cclxuXHJcbjxhcnRpY2xlPlxyXG4gIDxoZWFkZXI+XHJcbiAgICA8aDE+XHJcbiAgICAgIHt0aXRsZX1cclxuICAgICAgeyNpZiBpc0Zhdn0gPEJhZGdlPkZBVk9SSVRFPC9CYWRnZT4gey9pZn1cclxuICAgIDwvaDE+XHJcbiAgICA8aDI+e3N1YnRpdGxlfTwvaDI+XHJcbiAgICA8cD57YWRkcmVzc308L3A+XHJcbiAgPC9oZWFkZXI+XHJcbiAgPGRpdiBjbGFzcz1cImltYWdlXCI+XHJcbiAgICA8aW1nIHNyYz17aW1hZ2VVUkx9IGFsdD1cIlwiIC8+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgIDxwPntkZXNjcmlwdGlvbn08L3A+XHJcbiAgPC9kaXY+XHJcbiAgPGZvb3Rlcj5cclxuICAgIDxCdXR0b24gdHlwZT1cImJ1dHRvblwiIG1vZGU9XCJvdXRsaW5lXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdlZGl0JywgaWQpfVxyXG4gICAgICA+RWRpdDwvQnV0dG9uXHJcbiAgICA+XHJcbiAgICB7I2lmIGlzTG9hZGluZ31cclxuICAgICAgPHNwYW4+Q2hhbmdpbmcuLi48L3NwYW4+XHJcbiAgICB7OmVsc2V9XHJcbiAgICAgIDxCdXR0b25cclxuICAgICAgICBtb2RlPVwib3V0bGluZVwiXHJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgY29sb3I9e2lzRmF2ID8gdW5kZWZpbmVkIDogJ3N1Y2Nlc3MnfVxyXG4gICAgICAgIG9uOmNsaWNrPXt0b2dnbGVGYXZvcml0ZX0+e2lzRmF2ID8gJ1VuZmF2b3JpdGUnIDogJ0Zhdm9yaXRlJ308L0J1dHRvblxyXG4gICAgICA+XHJcbiAgICB7L2lmfVxyXG4gICAgPEJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaHJlZj1cIi97aWR9XCI+U2hvdyBEZXRhaWxzPC9CdXR0b24+XHJcbiAgPC9mb290ZXI+XHJcbjwvYXJ0aWNsZT5cclxuXHJcbjxzdHlsZT5cclxuICBhcnRpY2xlIHtcclxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMjYpO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICBtYXJnaW46IDFyZW07XHJcbiAgfVxyXG5cclxuICBoZWFkZXIsXHJcbiAgLmNvbnRlbnQsXHJcbiAgZm9vdGVyIHtcclxuICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgfVxyXG5cclxuICAuaW1hZ2Uge1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBoZWlnaHQ6IDE0cmVtO1xyXG4gIH1cclxuXHJcbiAgLmltYWdlIGltZyB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xyXG4gIH1cclxuXHJcbiAgaDEge1xyXG4gICAgZm9udC1zaXplOiAxLjI1cmVtO1xyXG4gICAgbWFyZ2luOiAwLjVyZW0gMDtcclxuICAgIGZvbnQtZmFtaWx5OiAnUm9ib3RvIFNsYWInLCBzYW5zLXNlcmlmO1xyXG4gIH1cclxuXHJcbiAgaDEuaXMtZmF2b3JpdGUge1xyXG4gICAgYmFja2dyb3VuZDogIzAxYTEyOTtcclxuICAgIGNvbG9yOiB3aGl0ZTtcclxuICAgIHBhZGRpbmc6IDAgMC41cmVtO1xyXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gIH1cclxuXHJcbiAgaDIge1xyXG4gICAgZm9udC1zaXplOiAxcmVtO1xyXG4gICAgY29sb3I6ICM4MDgwODA7XHJcbiAgICBtYXJnaW46IDAuNXJlbSAwO1xyXG4gIH1cclxuXHJcbiAgcCB7XHJcbiAgICBmb250LXNpemU6IDEuMjVyZW07XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgfVxyXG5cclxuICBkaXYge1xyXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XHJcbiAgfVxyXG5cclxuICAuY29udGVudCB7XHJcbiAgICBoZWlnaHQ6IDRyZW07XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcblxyXG4gIGxldCBjbGlja2VkQnV0dG9uID0gMDtcclxuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2PlxyXG4gIDxidXR0b25cclxuICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgY2xhc3M6YWN0aXZlPXtjbGlja2VkQnV0dG9uID09PSAwfVxyXG4gICAgb246Y2xpY2s9eygpID0+IHtcclxuICAgICAgY2xpY2tlZEJ1dHRvbiA9IDA7XHJcbiAgICAgIGRpc3BhdGNoKCdzZWxlY3QnLCAwKTtcclxuICAgIH19PkFsbDwvYnV0dG9uXHJcbiAgPlxyXG4gIDxidXR0b25cclxuICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgY2xhc3M6YWN0aXZlPXtjbGlja2VkQnV0dG9uID09PSAxfVxyXG4gICAgb246Y2xpY2s9eygpID0+IHtcclxuICAgICAgY2xpY2tlZEJ1dHRvbiA9IDE7XHJcbiAgICAgIGRpc3BhdGNoKCdzZWxlY3QnLCAxKTtcclxuICAgIH19PkZhdm9yaXRlPC9idXR0b25cclxuICA+XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG4gIGRpdiB7XHJcbiAgICBmb250LXNpemU6IDBweDtcclxuICB9XHJcblxyXG4gIGJ1dHRvbiB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjYWFhYWFhO1xyXG4gICAgZm9udDogaW5oZXJpdDtcclxuICAgIGZvbnQtc2l6ZTogMXJlbTtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNhYWFhYWE7XHJcbiAgICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcclxuICB9XHJcblxyXG4gIGJ1dHRvbjpmb2N1cyB7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gIH1cclxuXHJcbiAgYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xyXG4gICAgYm9yZGVyLXJhZGl1czogNXB4IDAgMCA1cHg7XHJcbiAgfVxyXG5cclxuICBidXR0b246bGFzdC1vZi10eXBlIHtcclxuICAgIGJvcmRlci1yYWRpdXM6IDAgNXB4IDVweCAwO1xyXG4gIH1cclxuXHJcbiAgYnV0dG9uOmhvdmVyLFxyXG4gIGJ1dHRvbjphY3RpdmUsXHJcbiAgLmFjdGl2ZSB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjY2YwMDU2O1xyXG4gICAgYm9yZGVyLWNvbG9yOiAjY2YwMDU2O1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsKSB7XHJcbiAgcmV0dXJuIHZhbC50cmltKCkubGVuZ3RoID09PSAwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEVtYWlsKHZhbCkge1xyXG4gIHJldHVybiBuZXcgUmVnRXhwKFxyXG4gICAgXCJbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86LlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/LikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1wiXHJcbiAgKS50ZXN0KHZhbCk7XHJcbn1cclxuIiwiPHNjcmlwdD5cclxuICBleHBvcnQgbGV0IGNvbnRyb2xUeXBlID0gdW5kZWZpbmVkO1xyXG4gIGV4cG9ydCBsZXQgaWQ7XHJcbiAgZXhwb3J0IGxldCBsYWJlbDtcclxuICBleHBvcnQgbGV0IHR5cGUgPSBcInRleHRcIjtcclxuICBleHBvcnQgbGV0IHZhbHVlO1xyXG4gIGV4cG9ydCBsZXQgcm93cyA9IDM7XHJcbiAgZXhwb3J0IGxldCB2YWxpZCA9IHRydWU7XHJcbiAgZXhwb3J0IGxldCB2YWxpZGl0eU1lc3NhZ2U7XHJcblxyXG4gIGxldCB0b3VjaGVkID0gZmFsc2U7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdiBjbGFzcz1cImZvcm0tY29udHJvbFwiPlxyXG4gIDxsYWJlbCBmb3I9e2lkfT57bGFiZWx9PC9sYWJlbD5cclxuICB7I2lmIGNvbnRyb2xUeXBlID09PSBcInRleHRhcmVhXCJ9XHJcbiAgICA8dGV4dGFyZWFcclxuICAgICAgY2xhc3M6aW52YWxpZD17IXZhbGlkICYmIHRvdWNoZWR9XHJcbiAgICAgIHtyb3dzfVxyXG4gICAgICB7aWR9XHJcbiAgICAgIGJpbmQ6dmFsdWVcclxuICAgICAgb246Ymx1cj17KCkgPT4gKHRvdWNoZWQgPSB0cnVlKX1cclxuICAgIC8+XHJcbiAgezplbHNlfVxyXG4gICAgPGlucHV0XHJcbiAgICAgIGNsYXNzOmludmFsaWQ9eyF2YWxpZCAmJiB0b3VjaGVkfVxyXG4gICAgICB7dHlwZX1cclxuICAgICAge2lkfVxyXG4gICAgICB7dmFsdWV9XHJcbiAgICAgIG9uOmlucHV0XHJcbiAgICAgIG9uOmJsdXI9eygpID0+ICh0b3VjaGVkID0gdHJ1ZSl9XHJcbiAgICAvPlxyXG4gIHsvaWZ9XHJcbiAgeyNpZiB2YWxpZGl0eU1lc3NhZ2UgJiYgIXZhbGlkICYmIHRvdWNoZWR9XHJcbiAgICA8ZGl2IGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPlxyXG4gICAgICB7dmFsaWRpdHlNZXNzYWdlfVxyXG4gICAgPC9kaXY+XHJcbiAgey9pZn1cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgaW5wdXQsXHJcbiAgdGV4dGFyZWEge1xyXG4gICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGZvbnQ6IGluaGVyaXQ7XHJcbiAgICBib3JkZXI6IG5vbmU7XHJcbiAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2NjYztcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweCAzcHggMCAwO1xyXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgICBwYWRkaW5nOiAwLjE1cmVtIDAuMjVyZW07XHJcbiAgICB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMC4xcyBlYXNlLW91dDtcclxuICB9XHJcblxyXG4gIGlucHV0OmZvY3VzLFxyXG4gIHRleHRhcmVhOmZvY3VzIHtcclxuICAgIGJvcmRlci1jb2xvcjogI2U0MDc2MztcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgfVxyXG5cclxuICBsYWJlbCB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gIH1cclxuXHJcbiAgLmZvcm0tY29udHJvbCB7XHJcbiAgICBwYWRkaW5nOiAwLjVyZW0gMDtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgbWFyZ2luOiAwLjI1cmVtIDA7XHJcbiAgfVxyXG5cclxuICAuaW52YWxpZCB7XHJcbiAgICBib3JkZXItY29sb3I6IHJlZDtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZGUzZTM7XHJcbiAgfVxyXG5cclxuICAuZXJyb3ItbWVzc2FnZSB7XHJcbiAgICBjb2xvcjogcmVkO1xyXG4gICAgbWFyZ2luOiAwLjI1cmVtIDA7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCBtZWV0dXBzIGZyb20gJy4uLy4uL21lZXR1cHMtc3RvcmUnO1xyXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgaXNFbXB0eSwgaXNWYWxpZEVtYWlsIH0gZnJvbSAnLi4vLi4vaGVscGVycy92YWxpZGF0aW9uJztcclxuICBpbXBvcnQgTW9kYWwgZnJvbSAnLi4vVUkvTW9kYWwuc3ZlbHRlJztcclxuICBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL1VJL0J1dHRvbi5zdmVsdGUnO1xyXG4gIGltcG9ydCBUZXh0SW5wdXQgZnJvbSAnLi4vVUkvVGV4dElucHV0LnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEVycm9yIGZyb20gJy4uL1VJL0Vycm9yLnN2ZWx0ZSc7XHJcblxyXG4gIGV4cG9ydCBsZXQgaWQ7XHJcblxyXG4gIGxldCB0aXRsZSA9ICcnO1xyXG4gIGxldCBzdWJ0aXRsZSA9ICcnO1xyXG4gIGxldCBhZGRyZXNzID0gJyc7XHJcbiAgbGV0IGltYWdlVVJMID0gJyc7XHJcbiAgbGV0IGVtYWlsID0gJyc7XHJcbiAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XHJcbiAgbGV0IGVycm9yO1xyXG5cclxuICBpZiAoaWQpIHtcclxuICAgIGNvbnN0IHVuc3VzY3JpYmUgPSBtZWV0dXBzLnN1YnNjcmliZSgoaXRlbXMpID0+IHtcclxuICAgICAgY29uc3Qgc2VsZWN0ZWRNZWV0dXAgPSBpdGVtcy5maW5kKChpKSA9PiBpLmlkID09PSBpZCk7XHJcblxyXG4gICAgICB0aXRsZSA9IHNlbGVjdGVkTWVldHVwLnRpdGxlO1xyXG4gICAgICBzdWJ0aXRsZSA9IHNlbGVjdGVkTWVldHVwLnN1YnRpdGxlO1xyXG4gICAgICBhZGRyZXNzID0gc2VsZWN0ZWRNZWV0dXAuYWRkcmVzcztcclxuICAgICAgaW1hZ2VVUkwgPSBzZWxlY3RlZE1lZXR1cC5pbWFnZVVSTDtcclxuICAgICAgZW1haWwgPSBzZWxlY3RlZE1lZXR1cC5jb250YWN0RW1haWw7XHJcbiAgICAgIGRlc2NyaXB0aW9uID0gc2VsZWN0ZWRNZWV0dXAuZGVzY3JpcHRpb247XHJcbiAgICB9KTtcclxuXHJcbiAgICB1bnN1c2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgJDogdGl0bGVWYWxpZCA9ICFpc0VtcHR5KHRpdGxlKTtcclxuICAkOiBzdWJ0aXRsZVZhbGlkID0gIWlzRW1wdHkoc3VidGl0bGUpO1xyXG4gICQ6IGFkZHJlc3NWYWxpZCA9ICFpc0VtcHR5KGFkZHJlc3MpO1xyXG4gICQ6IGltYWdlVVJMVmFsaWQgPSAhaXNFbXB0eShpbWFnZVVSTCk7XHJcbiAgJDogZGVzY3JpcHRpb25WYWxpZCA9ICFpc0VtcHR5KGRlc2NyaXB0aW9uKTtcclxuICAkOiBlbWFpbFZhbGlkID0gaXNWYWxpZEVtYWlsKGVtYWlsKTtcclxuICAkOiBpc0Zvcm1WYWxpZCA9XHJcbiAgICB0aXRsZVZhbGlkICYmXHJcbiAgICBzdWJ0aXRsZVZhbGlkICYmXHJcbiAgICBhZGRyZXNzVmFsaWQgJiZcclxuICAgIGltYWdlVVJMVmFsaWQgJiZcclxuICAgIGRlc2NyaXB0aW9uVmFsaWQgJiZcclxuICAgIGVtYWlsVmFsaWQ7XHJcblxyXG4gIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oKSB7XHJcbiAgICBjb25zdCBtZWV0dXBEYXRhID0ge1xyXG4gICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgIHN1YnRpdGxlOiBzdWJ0aXRsZSxcclxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICBpbWFnZVVSTDogaW1hZ2VVUkwsXHJcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXHJcbiAgICAgIGNvbnRhY3RFbWFpbDogZW1haWwsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpZCkge1xyXG4gICAgICBmZXRjaChcclxuICAgICAgICBgaHR0cHM6Ly9tZWV0dXBzLWUyZTRiLWRlZmF1bHQtcnRkYi5maXJlYmFzZWlvLmNvbS9tZWV0dXBzLyR7aWR9Lmpzb25gLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZWV0dXBEYXRhKSxcclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgICAgICAudGhlbigocmVzKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCEnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBtZWV0dXBzLnVwZGF0ZU1lZXR1cChpZCwgbWVldHVwRGF0YSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZmV0Y2goJ2h0dHBzOi8vbWVldHVwcy1lMmU0Yi1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb20vbWVldHVwcy5qc29uJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IC4uLm1lZXR1cERhdGEsIGlzRmF2b3JpdGU6IGZhbHNlIH0pLFxyXG4gICAgICB9KVxyXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIScpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgIG1lZXR1cHMuYWRkTWVldHVwKHtcclxuICAgICAgICAgICAgLi4ubWVldHVwRGF0YSxcclxuICAgICAgICAgICAgaXNGYXZvcml0ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGlkOiBkYXRhLm5hbWUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICBlcnJvciA9IGVycjtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaCgnc2F2ZScpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xyXG4gICAgZGlzcGF0Y2goJ2NhbmNlbCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVsZXRlTWVldHVwKCkge1xyXG4gICAgZmV0Y2goXHJcbiAgICAgIGBodHRwczovL21lZXR1cHMtZTJlNGItZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tL21lZXR1cHMvJHtpZH0uanNvbmAsXHJcbiAgICAgIHsgbWV0aG9kOiAnREVMRVRFJyB9XHJcbiAgICApXHJcbiAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZWV0dXBzLmRlbGV0ZU1lZXR1cChpZCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgZGlzcGF0Y2goJ3NhdmUnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3IoKSB7XHJcbiAgICBlcnJvciA9IG51bGw7XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbnsjaWYgZXJyb3J9XHJcbiAgPEVycm9yIG1lc3NhZ2U9e2Vycm9yLm1lc3NhZ2V9IC8+XHJcbnsvaWZ9XHJcblxyXG48TW9kYWwgdGl0bGU9XCJFZGl0IE1lZXR1cCBEYXRhXCIgb246Y2FuY2VsPlxyXG4gIDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17c3VibWl0Rm9ybX0+XHJcbiAgICA8VGV4dElucHV0XHJcbiAgICAgIGlkPVwidGl0bGVcIlxyXG4gICAgICBsYWJlbD1cIlRpdGxlXCJcclxuICAgICAgdmFsdWU9e3RpdGxlfVxyXG4gICAgICB2YWxpZD17dGl0bGVWYWxpZH1cclxuICAgICAgdmFsaWRpdHlNZXNzYWdlPVwiUGxlYXNlIGVudGVyIGEgdmFsaWQgdGl0bGUuXCJcclxuICAgICAgb246aW5wdXQ9eyhlKSA9PiAodGl0bGUgPSBlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAvPlxyXG4gICAgPFRleHRJbnB1dFxyXG4gICAgICBpZD1cInN1YnRpdGxlXCJcclxuICAgICAgbGFiZWw9XCJTdWIgVGl0bGVcIlxyXG4gICAgICB2YWx1ZT17c3VidGl0bGV9XHJcbiAgICAgIHZhbGlkPXtzdWJ0aXRsZVZhbGlkfVxyXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBzdWJ0aXRsZS5cIlxyXG4gICAgICBvbjppbnB1dD17KGUpID0+IChzdWJ0aXRsZSA9IGUudGFyZ2V0LnZhbHVlKX1cclxuICAgIC8+XHJcbiAgICA8VGV4dElucHV0XHJcbiAgICAgIGlkPVwiYWRkcmVzc1wiXHJcbiAgICAgIGxhYmVsPVwiQWRkcmVzc1wiXHJcbiAgICAgIHZhbHVlPXthZGRyZXNzfVxyXG4gICAgICB2YWxpZD17YWRkcmVzc1ZhbGlkfVxyXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBhZGRyZXNzLlwiXHJcbiAgICAgIG9uOmlucHV0PXsoZSkgPT4gKGFkZHJlc3MgPSBlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAvPlxyXG4gICAgPFRleHRJbnB1dFxyXG4gICAgICBpZD1cImltYWdlVVJMXCJcclxuICAgICAgbGFiZWw9XCJJbWFnZSBVUkxcIlxyXG4gICAgICB2YWx1ZT17aW1hZ2VVUkx9XHJcbiAgICAgIHZhbGlkPXtpbWFnZVVSTFZhbGlkfVxyXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBpbWFnZSB1cmwuXCJcclxuICAgICAgb246aW5wdXQ9eyhlKSA9PiAoaW1hZ2VVUkwgPSBlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAvPlxyXG4gICAgPFRleHRJbnB1dFxyXG4gICAgICBpZD1cImVtYWlsXCJcclxuICAgICAgbGFiZWw9XCJFLU1haWxcIlxyXG4gICAgICB0eXBlPVwiZW1haWxcIlxyXG4gICAgICB2YWx1ZT17ZW1haWx9XHJcbiAgICAgIHZhbGlkPXtlbWFpbFZhbGlkfVxyXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlwiXHJcbiAgICAgIG9uOmlucHV0PXsoZSkgPT4gKGVtYWlsID0gZS50YXJnZXQudmFsdWUpfVxyXG4gICAgLz5cclxuICAgIDxUZXh0SW5wdXRcclxuICAgICAgaWQ9XCJkZXNjcmlwdGlvblwiXHJcbiAgICAgIGxhYmVsPVwiRGVzY3JpcHRpb25cIlxyXG4gICAgICBjb250cm9sVHlwZT1cInRleHRhcmVhXCJcclxuICAgICAgYmluZDp2YWx1ZT17ZGVzY3JpcHRpb259XHJcbiAgICAgIHZhbGlkPXtkZXNjcmlwdGlvblZhbGlkfVxyXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkZXNjcmlwdGlvbi5cIlxyXG4gICAgLz5cclxuICA8L2Zvcm0+XHJcblxyXG4gIDxkaXYgc2xvdD1cImZvb3RlclwiPlxyXG4gICAgPEJ1dHRvbiBtb2RlPVwib3V0bGluZVwiIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17Y2FuY2VsfT5DYW5jZWw8L0J1dHRvbj5cclxuICAgIDxCdXR0b24gdHlwZT1cImJ1dHRvblwiIG9uOmNsaWNrPXtzdWJtaXRGb3JtfSBkaXNhYmxlZD17IWlzRm9ybVZhbGlkfVxyXG4gICAgICA+U2F2ZTwvQnV0dG9uXHJcbiAgICA+XHJcbiAgICB7I2lmIGlkfVxyXG4gICAgICA8QnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17ZGVsZXRlTWVldHVwfT5EZWxldGU8L0J1dHRvbj5cclxuICAgIHsvaWZ9XHJcbiAgPC9kaXY+XHJcbjwvTW9kYWw+XHJcblxyXG48c3R5bGU+XHJcbiAgZm9ybSB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICB9XHJcbjwvc3R5bGU+XHJcbiIsIjxkaXYgY2xhc3M9XCJsb2FkaW5nXCI+XHJcbiAgPGRpdiBjbGFzcz1cImxkcy1yaW5nXCI+XHJcbiAgICA8ZGl2IC8+XHJcbiAgICA8ZGl2IC8+XHJcbiAgICA8ZGl2IC8+XHJcbiAgICA8ZGl2IC8+XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG4gIC5sb2FkaW5nIHtcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBwbGFjZS1pdGVtczogY2VudGVyO1xyXG5cclxuICAgIG1hcmdpbjogMnJlbTtcclxuICB9XHJcblxyXG4gIC5sZHMtcmluZyB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB3aWR0aDogODBweDtcclxuICAgIGhlaWdodDogODBweDtcclxuICB9XHJcbiAgLmxkcy1yaW5nIGRpdiB7XHJcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB3aWR0aDogNjRweDtcclxuICAgIGhlaWdodDogNjRweDtcclxuICAgIG1hcmdpbjogOHB4O1xyXG4gICAgYm9yZGVyOiA4cHggc29saWQgI2NmMDA1NjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICAgIGFuaW1hdGlvbjogbGRzLXJpbmcgMS4ycyBjdWJpYy1iZXppZXIoMC41LCAwLCAwLjUsIDEpIGluZmluaXRlO1xyXG4gICAgYm9yZGVyLWNvbG9yOiAjY2YwMDU2IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xyXG4gIH1cclxuICAubGRzLXJpbmcgZGl2Om50aC1jaGlsZCgxKSB7XHJcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjQ1cztcclxuICB9XHJcbiAgLmxkcy1yaW5nIGRpdjpudGgtY2hpbGQoMikge1xyXG4gICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4zcztcclxuICB9XHJcbiAgLmxkcy1yaW5nIGRpdjpudGgtY2hpbGQoMykge1xyXG4gICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4xNXM7XHJcbiAgfVxyXG4gIEBrZXlmcmFtZXMgbGRzLXJpbmcge1xyXG4gICAgMCUge1xyXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xyXG4gICAgfVxyXG4gIH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHByZWxvYWQocGFnZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goXHJcbiAgICAgICdodHRwczovL21lZXR1cHMtZTJlNGItZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tL21lZXR1cHMuanNvbidcclxuICAgIClcclxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xyXG4gICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZldGNoaW5nIG1lZXR1cHMgZmFpbGVkLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcclxuICAgICAgfSlcclxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBmZXRjaGVkTWVldHVwcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgIGZldGNoZWRNZWV0dXBzLnB1c2goe1xyXG4gICAgICAgICAgICAuLi5kYXRhW2tleV0sXHJcbiAgICAgICAgICAgIGlkOiBrZXksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IGZldGNoZWRNZWV0dXBzOiBmZXRjaGVkTWVldHVwcy5yZXZlcnNlKCkgfTtcclxuICAgICAgICAvLyBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAvLyAgIGlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vICAgbWVldHVwcy5zZXRNZWV0dXBzKGZldGNoZWRNZWV0dXBzLnJldmVyc2UoKSk7XHJcbiAgICAgICAgLy8gfSwgMTAwMCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgICB0aGlzLmVycm9yKDUwMCwgJ0NvdWxkIG5vdCBsb2FkIG1lZXR1cHMhJyk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c2NyaXB0PlxyXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25Nb3VudCwgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJztcclxuICBpbXBvcnQgeyBzY2FsZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcclxuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnO1xyXG4gIGltcG9ydCBtZWV0dXBzIGZyb20gJy4uL21lZXR1cHMtc3RvcmUuanMnO1xyXG4gIGltcG9ydCBNZWV0dXBJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvTWVldHVwL01lZXR1cEl0ZW0uc3ZlbHRlJztcclxuICBpbXBvcnQgTWVldHVwRmlsdGVyIGZyb20gJy4uL2NvbXBvbmVudHMvTWVldHVwL01lZXR1cEZpbHRlci5zdmVsdGUnO1xyXG4gIGltcG9ydCBCdXR0b24gZnJvbSAnLi4vY29tcG9uZW50cy9VSS9CdXR0b24uc3ZlbHRlJztcclxuICBpbXBvcnQgRWRpdE1lZXR1cCBmcm9tICcuLi9jb21wb25lbnRzL01lZXR1cC9FZGl0TWVldHVwLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IExvYWRpbmdTcGlubmVyIGZyb20gJy4uL2NvbXBvbmVudHMvVUkvTG9hZGluZ1NwaW5uZXIuc3ZlbHRlJztcclxuXHJcbiAgZXhwb3J0IGxldCBmZXRjaGVkTWVldHVwcztcclxuXHJcbiAgbGV0IGVkaXRNb2RlO1xyXG4gIGxldCBlZGl0ZWRJZDtcclxuICBsZXQgaXNMb2FkaW5nO1xyXG4gIGxldCB1bnN1YnNjcmliZTtcclxuXHJcbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcbiAgbGV0IGZhdnNPbmx5ID0gZmFsc2U7XHJcblxyXG4gIG9uTW91bnQoKCkgPT4ge1xyXG4gICAgbWVldHVwcy5zZXRNZWV0dXBzKGZldGNoZWRNZWV0dXBzKTtcclxuXHJcbiAgICB1bnN1YnNjcmliZSA9IG1lZXR1cHMuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xyXG4gICAgICBmZXRjaGVkTWVldHVwcyA9IGl0ZW1zO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIG9uRGVzdHJveSgoKSA9PiB7XHJcbiAgICBpZiAodW5zdWJzY3JpYmUpIHtcclxuICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgJDogZmlsdGVyZWRNZWV0dXBzID0gZmF2c09ubHlcclxuICAgID8gZmV0Y2hlZE1lZXR1cHMuZmlsdGVyKChtKSA9PiBtLmlzRmF2b3JpdGUpXHJcbiAgICA6IGZldGNoZWRNZWV0dXBzO1xyXG5cclxuICBmdW5jdGlvbiBmaWx0ZXJNZWV0dXAoZXZlbnQpIHtcclxuICAgIGZhdnNPbmx5ID0gZXZlbnQuZGV0YWlsID09PSAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2F2ZWRNZWV0dXAoZXZlbnQpIHtcclxuICAgIGVkaXRNb2RlID0gbnVsbDtcclxuICAgIGVkaXRlZElkID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbEVkaXQoKSB7XHJcbiAgICBlZGl0TW9kZSA9IG51bGw7XHJcbiAgICBlZGl0ZWRJZCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdGFydEVkaXQoZXZlbnQpIHtcclxuICAgIGVkaXRNb2RlID0gJ2VkaXQnO1xyXG4gICAgZWRpdGVkSWQgPSBldmVudC5kZXRhaWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRBZGQoKSB7XHJcbiAgICBlZGl0TW9kZSA9ICdlZGl0JztcclxuICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG4gIDx0aXRsZT5BbGwgTWVldHVwczwvdGl0bGU+XHJcbjwvc3ZlbHRlOmhlYWQ+XHJcblxyXG57I2lmIGVkaXRNb2RlID09PSAnZWRpdCd9XHJcbiAgPEVkaXRNZWV0dXAgaWQ9e2VkaXRlZElkfSBvbjpzYXZlPXtzYXZlZE1lZXR1cH0gb246Y2FuY2VsPXtjYW5jZWxFZGl0fSAvPlxyXG57L2lmfVxyXG57I2lmIGlzTG9hZGluZ31cclxuICA8TG9hZGluZ1NwaW5uZXIgLz5cclxuezplbHNlfVxyXG4gIDxzZWN0aW9uIGlkPVwibWVldHVwLWNvbnRyb2xzXCI+XHJcbiAgICA8TWVldHVwRmlsdGVyIG9uOnNlbGVjdD17ZmlsdGVyTWVldHVwfSAvPlxyXG4gICAgPEJ1dHRvbiBvbjpjbGljaz17c2V0QWRkfT5OZXcgTWVldHVwPC9CdXR0b24+XHJcbiAgPC9zZWN0aW9uPlxyXG5cclxuICB7I2lmIGZpbHRlcmVkTWVldHVwcy5sZW5ndGggPT09IDB9XHJcbiAgICA8ZGl2IGlkPVwibm8tbWVldHVwc1wiPk5vIG1lZXR1cHMgeWV0LCBzdGFydCBieSBhZGRpbmcgc29tZS48L2Rpdj5cclxuICB7OmVsc2V9XHJcbiAgICA8c2VjdGlvbiBpZD1cIm1lZXR1cHNcIj5cclxuICAgICAgeyNlYWNoIGZpbHRlcmVkTWVldHVwcyBhcyBtZWV0dXAgKG1lZXR1cC5pZCl9XHJcbiAgICAgICAgPGRpdiBpbjpzY2FsZSBhbmltYXRlOmZsaXA9e3sgZHVyYXRpb246IDMwMCB9fT5cclxuICAgICAgICAgIDxNZWV0dXBJdGVtXHJcbiAgICAgICAgICAgIGlkPXttZWV0dXAuaWR9XHJcbiAgICAgICAgICAgIHRpdGxlPXttZWV0dXAudGl0bGV9XHJcbiAgICAgICAgICAgIHN1YnRpdGxlPXttZWV0dXAuc3VidGl0bGV9XHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXttZWV0dXAuZGVzY3JpcHRpb259XHJcbiAgICAgICAgICAgIGltYWdlVVJMPXttZWV0dXAuaW1hZ2VVUkx9XHJcbiAgICAgICAgICAgIGFkZHJlc3M9e21lZXR1cC5hZGRyZXNzfVxyXG4gICAgICAgICAgICBlbWFpbD17bWVldHVwLmNvbnRhY3RFbWFpbH1cclxuICAgICAgICAgICAgaXNGYXY9e21lZXR1cC5pc0Zhdm9yaXRlfVxyXG4gICAgICAgICAgICBvbjplZGl0PXtzdGFydEVkaXR9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICB7L2VhY2h9XHJcbiAgICA8L3NlY3Rpb24+XHJcbiAgey9pZn1cclxuey9pZn1cclxuXHJcbjxzdHlsZT5cclxuICAjbWVldHVwcyB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGRpc3BsYXk6IGdyaWQ7XHJcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcclxuICAgIGdyaWQtZ2FwOiAxcmVtO1xyXG4gIH1cclxuXHJcbiAgI21lZXR1cC1jb250cm9scyB7XHJcbiAgICBtYXJnaW46IDFyZW07XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIH1cclxuXHJcbiAgI25vLW1lZXR1cHMge1xyXG4gICAgbWFyZ2luOiAxcmVtO1xyXG4gIH1cclxuXHJcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XHJcbiAgICAjbWVldHVwcyB7XHJcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIDFmcik7XHJcbiAgICB9XHJcbiAgfVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOlsiRXJyb3IiLCJtZWV0dXBzIl0sIm1hcHBpbmdzIjoiOzs7QUFHQSxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRTtBQUMvQyxJQUFJLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLElBQUksTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsS0FBSyxNQUFNLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7QUFDeEUsSUFBSSxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUN0RSxJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxLQUFLLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDekUsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLE1BQU0sS0FBSyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ3pFLElBQUksTUFBTSxF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
